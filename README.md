# Индивидуальное домашнее задание №2

#### Студент: Нечесов Андрей Львович
#### Группа: БПИ217
#### Вариант: 25
## Содержание
- [Условие к варианту](#условие-к-варианту)
- [Формат работы программы](#формат-работы-программы)
- [Тестирующий скрипт](#тестирующий-скрипт)
- [Критерии на 4 балла](#критерии-на-4-балла)
	- [Решение на C](#написано-решение-на-c)
	- [Программа на ассемблере](#комментарии-к-программе-на-ассемблере-и-компиляция-программы)
	- [Модификация программы](#из-ассемблерной-программы-убраны-лишние-макросы)
	- [Тестирование программ](#тестирование-программ)

## Условие к варианту
>Разработать программу, которая определяет в ASCII-строке частоту встречаемости различных идентификаторов, являющихся словами, состоящими из букв и цифр, начинающихся с буквы. Разделителями являются все другие символы. Для тестирования можно использовать программы, написанные на различных языках программирования.

Вывод идентификаторов и частоты их встречаемости организован в том порядке, в котором идентификаторы встречаются в файле/строке.


## Формат работы программы
```
./solution [-i INPUT_FILE] [-o OUTPUT_FILE] [-s SEED] [-r IDENTIFIERS_N] [-t TESTS_N]
```
`-i INPUT_FILE` указывает на то, что данные нужно читать с файла. В качестве аргумента требуется указать путь ко входному файлу.   
`-o OUTPUT_FILE` указывает на то, что данные нужно выводить в файл. В качестве аргумента опция требуется указать путь к выходному файлу.   
`-r IDENTIFIERS_N` указывает на то, что программа сама должна сгенерировать данные. В качестве аргумента необходимо передать количество идентификаторов. В результате программа генерирует случайный тест с `IDENTIFIERS_N` идентификаторами, выводит сам тест в консоль и ответ на него.  
`-s SEED` семя рандома. В качестве аргумента нужно указать целое число от 1 до 1'000'000.  
`-t TESTS_N` указывает на то, что программа должна провести замер времени работы. В качестве аргумента опции необходимо передать количество тестов для замера времени. В консоль выводится суммарное время затраченное на `TESTS_N` тестов.

## Тестирующий скрипт
Для удобства тестирования программы был написан скрипт [checker.py](checker.py)
```
usage: checker.py [-h] [-f] [-v] path_to_program path_to_tests

Checker for IHW2

positional arguments:
  path_to_program
  path_to_tests

optional arguments:
  -h, --help       show this help message and exit
  -f, --use-files
  -v, --verbose
```

В папке с тестами файлы должны быть именованы следующим образом: \
<Имя файла с тестом> &mdash; сам тест \
<Имя файла с тестом>.a &mdash; ответ на тест

## Критерии на 4 балла
### Написано решение на C
Исходный монолитный код на языке C: [src/solution.c](src/solution.c)
### Комментарии к программе на ассемблере и компиляция программы

Трансформируем код написанный на языке C в язык ассемблера:
```console
gcc -masm=intel -fno-asynchronous-unwind-tables -fno-jump-tables -fno-stack-protector -fno-exceptions solution.c -S -o solution.s
```

Код на языке ассемблера прокомментирован: [src/commented.s](src/commented.s)

Откомпилируем полученную программу без использования отладочных и оптимизируюзих опций:
```console
gcc commented.s -o commented
```
 
### Из ассемблерной программы убраны лишние макросы
Часть работы уже была проделана опциями при трансформации. Теперь руками уберем из ассемблерной программы метаинформацию:
```assembly
	.ident	"GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0"
	.section	.note.GNU-stack,"",@progbits
	.section	.note.gnu.property,"a"
	.align 8
	.long	 1f - 0f
	.long	 4f - 1f
	.long	 5
0:
	.string	 "GNU"
1:
	.align 8
	.long	 0xc0000002
	.long	 3f - 2f
2:
	.long	 0x3
3:
	.align 8
4:
```
И следующие команды:  
`endbr64` обеспечивает дополнительную безопасность, но в нашем идеальном мире ИДЗ нет злых хакеров, поэтому удаляем команду.  
`nop` используется для выравнивания, так как подчистили всю метаинформацию, можно тоже удалить.

Итоговая модифицированная программа: [src/reduced.s](src/reduced.s)
### Модифицированная ассемблерная программа отдельно откомпилирована
```console
gcc reduced.s -o reduced
```
### Тестирование программ
Был составлен набор тестов для проверки работы программы на следующих входных данных:
1.	Пустой ввод
2.	Строка с разделителями и цифрами без букв
3.	Один идентификатор в строке
4.	Строка со словами, которые начинаются с цифр, и идентификаторами
5.	Файл №1 на языке С
6.	Файл №2 на языке С
7.	Случайная строка с идентификаторами, два из которых повторяются хотя бы два раза

Все тесты лежат в папке [tests](tests/) и имеют в названии номер соответствующий списку выше.

Используем скрипт [checker.py](checker.py) с опцией `-v` для вывода подробных результатов тестирования:

```console
./checker.py -v src/commented tests/
./checker.py -v src/reduced tests/
```
Получаем одинаковые результаты тестирования для программ:
[commented.s](src/commented.s)            | [reduced.s](src/reduced.s)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
:-------------------------:|:-------------------------:
![](screenshots/test_commented.jpg)  |  ![](screenshots/test_reduced.jpg)

## Критерии на 5 баллов
Программа на C изначально была написана так, что в ней использовались и локальные переменные, и вызовы функций с передачей параметров. Исходный код на языке ассемблера также содержит требуемые комментарии на оценку 5: [reduced.s](https://github.com/Bopobywek/csa-ihw1/blob/main/src/reduced.s)

## Критерии на 6 баллов
### Рефакторинг программы на ассемблере
В первую очередь оптимизация проводилась для функций, от которых прямо зависит скорость решения задачи: `min`, `isAlpha`, `isAlphaOrNum`, `incrementElement`, `parseIdentifiers`.  

Так, удалось полностью заменить использование стека на регистры в функциях `min`, `isAlpha` и `isAlphaOrNum`. Причем из-за того, что эти функции либо не вызывают никакие другие функции, либо вызывают только друг друга, получилось сократить и количество обменов значений между регистрами. В итоге, эти три функции используют лишь два регистра `rax` и `rdi`.  

В функциях `incrementElement` и `parseIdentifiers` хранение локальных переменных на стеке практически полностью заменено на хранение локальных переменных в регистрах: замена не проводилась только для переменных, которые используются редко. Таким образом, в результате оптимизации были использованы все доступные callee-saved регистры: `rbx`, `r12-r15`. К тому же в прологе функции `incrementElement` значения некоторых регистров сохраняются на стек для частичного соблюдения соглашений по callee-saved регистрам, так как эту функцию вызывает `parseIdentifiers` и в противном случае регистров бы не хватило.

Также использование стека на использование регистров для хранения локальных переменных было заменено (насколько хватило регистров:)) в следующих функциях: `readStringInBuffer`, `writeMapToOutputStream` и `fillBufferRandomly`.

### Добавление комментариев в разработанную программу
Исходный код оптимизированной программы: [optimized.s](src/optimized.s) (прокомментирован)

