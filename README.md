# Индивидуальное домашнее задание №2

#### Студент: Нечесов Андрей Львович
#### Группа: БПИ217
#### Вариант: 25
## Содержание
- [Условие к варианту](#условие-к-варианту)
- [Формат работы программы](#формат-работы-программы)

## Условие к варианту
```plain
Сформировать массив B из элементов массива A заменой всех нулевых элементов значением минимального элемента.
Разработать программу, которая определяет в ASCII-строке частоту встречаемости различных идентификаторов,
являющихся словами, состоящими из букв и цифр, начинающихся с буквы. Разделителями являются все другие символы.
Для тестирования можно использовать программы, написанные на различных языках программирования.
```

## Формат работы программы
```
./solution [-i INPUT_FILE] [-o OUTPUT_FILE] [-s SEED] [-r IDENTIFIERS_COUNT] [-t TESTS_N]
```
`-i INPUT_FILE` указывает на то, что данные нужно читать с файла. В качестве аргумента требуется указать путь ко входному файлу.   
`-o OUTPUT_FILE` указывает на то, что данные нужно выводить в файл. В качестве аргумента опция требуется указать путь к выходному файлу.   
`-r IDENTIFIERS_N` указывает на то, что программа сама должна сгенерировать данные. В качестве аргумента необходимо передать количество идентификаторов. В результате программа генерирует случайный тест с `IDENTIFIERS_N` идентификаторами, выводит сам тест в консоль и ответ на него.  
`-s SEED` семя рандома. В качестве аргумента нужно указать целое число от 1 до 1'000'000.  
`-t TESTS_N` указывает на то, что программа должна провести замер времени работы. В качестве аргумента опции необходимо передать количество тестов для замера времени. В консоль выводится суммарное время затраченное на `TESTS_N` тестов.

## Тестирующий скрипт
Для удобства тестирования программы был написан скрипт [checker.py](checker.py)
```
usage: checker.py [-h] [-f] [-v] path_to_program path_to_tests

Checker for IHW2

positional arguments:
  path_to_program
  path_to_tests

optional arguments:
  -h, --help       show this help message and exit
  -f, --use-files
  -v, --verbose
```

Папка с тестами должна быть организована следующим образом:

## Критерии на 4 балла
### Написано решение на C
Исходный монолитный код на языке C: [src/solution.c](src/solution.c)
### Комментарии к программе на ассемблере и компиляция программы

Трансформируем код написанный на языке C в язык ассемблера:
```console
gcc -masm=intel -fno-asynchronous-unwind-tables -fno-jump-tables -fno-stack-protector -fno-exceptions solution.c -S -o solution.s
```

Код на языке ассемблера прокомментирован: [src/commented.s](src/commented.s)

Откомпилируем полученную программу без использования отладочных и оптимизируюзих опций:
```console
gcc commented.s -o solution
```
 
### Из ассемблерной программы убраны лишние макросы
Часть работы уже была проделана опциями при трансформации. Теперь руками уберем из ассемблерной программы метаинформацию:
```assembly
	.ident	"GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0"
	.section	.note.GNU-stack,"",@progbits
	.section	.note.gnu.property,"a"
	.align 8
	.long	 1f - 0f
	.long	 4f - 1f
	.long	 5
0:
	.string	 "GNU"
1:
	.align 8
	.long	 0xc0000002
	.long	 3f - 2f
2:
	.long	 0x3
3:
	.align 8
4:
```
И следующие команды:  
`endbr64` обеспечивает дополнительную безопасность, но в нашем идеально мире ИДЗ нет злых хакеров, поэтому удаляем команду.  
`nop` используется для выравнивания, так как подчистили всю метаинформацию, можно тоже удалить.

Итоговая модифицированная программа: [src/reduced.s](src/reduced.s)
### Модифицированная ассемблерная программа отдельно откомпилирована
```console
gcc reduced.s -o reduced
```
### Тестирование программ
Был составлен небольшой набор тестов для проверки граничных случаев:
0. Весь входной массив состоит из нулей
1. Во входном массиве нет нулей
2. Во входном массиве есть числа как меньше нуля, так и больше
3. Входной массив размера 1, причем элемент массива не равен 0
4. Входной массив размера 1, причем этот единственный элемент является нулем
5. Случайный массив
